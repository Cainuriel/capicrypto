# @noble/curves - Custom Weierstrass Curve Implementation Guide

## AI-Optimized Documentation for Custom Elliptic Curve Cryptography

**Version**: 2.0.1  
**Purpose**: Complete reference for creating custom Weierstrass elliptic curves with ECDSA signatures  
**Source**: https://github.com/paulmillr/noble-curves

---

## Installation

```bash
npm install @noble/curves
```

**Dependencies**: `@noble/hashes` (included automatically)

---

## Core Concept: Creating Custom Weierstrass Curves

### What is a Weierstrass Curve?

Short Weierstrass curve formula: **y² = x³ + ax + b**

The `weierstrass()` function creates a custom elliptic curve Point class.

---

## Function Signature: `weierstrass()`

```javascript
import { weierstrass } from '@noble/curves/abstract/weierstrass.js';

const CustomPoint = weierstrass(curveParams);
```

### Required Parameters (`WeierstrassOpts<T>`)

```typescript
type WeierstrassOpts<T> = {
  p: bigint;    // Field characteristic (prime modulus)
  n: bigint;    // Curve order (number of points in the group generated by G)
  h: bigint;    // Cofactor (usually 1n for prime-order curves)
  a: T;         // Curve parameter 'a' in y² = x³ + ax + b
  b: T;         // Curve parameter 'b' in y² = x³ + ax + b
  Gx: T;        // Generator point X coordinate
  Gy: T;        // Generator point Y coordinate
};
```

**Critical Notes**:
- All numeric parameters must be `bigint` type (use `n` suffix: `123n`)
- `p` must be a prime number (field characteristic)
- `n` must be the **exact order** of the subgroup generated by point G
- The library **validates** that `n * G = O` (point at infinity)
- `a`, `b`, `Gx`, `Gy` must be valid field elements (0 ≤ value < p)

---

## Complete Example: Custom p192 Curve

```javascript
import { weierstrass } from '@noble/curves/abstract/weierstrass.js';

// NIST secp192r1 aka p192
const p192_CURVE = {
  p: 0xfffffffffffffffffffffffffffffffeffffffffffffffffn,
  n: 0xffffffffffffffffffffffff99def836146bc9b1b4d22831n,
  h: 1n,
  a: 0xfffffffffffffffffffffffffffffffefffffffffffffffcn,
  b: 0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1n,
  Gx: 0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012n,
  Gy: 0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811n,
};

const p192_Point = weierstrass(p192_CURVE);
```

---

## Creating ECDSA Signature Instance

After creating the Point class, create an ECDSA instance for signing/verification:

```javascript
import { ecdsa } from '@noble/curves/abstract/weierstrass.js';
import { sha256 } from '@noble/hashes/sha2.js';

const p192_ecdsa = ecdsa(p192_Point, sha256);

// Generate key pair
const keys = p192_ecdsa.keygen();

// Sign message
const msg = new TextEncoder().encode('custom curve');
const sig = p192_ecdsa.sign(msg, keys.secretKey);

// Verify signature
const isValid = p192_ecdsa.verify(sig, msg, keys.publicKey);
```

---

## Point Class API

### Static Properties

```javascript
Point.BASE        // Generator point G
Point.ZERO        // Point at infinity (identity element)
Point.Fp          // Field for coordinates (mod p)
Point.Fn          // Scalar field (mod n)
```

### Point Construction

```javascript
// From coordinates (projective: X, Y, Z where x=X/Z, y=Y/Z)
const p = new Point(X, Y, Z);

// From affine coordinates
const p = Point.fromAffine({ x: xBigInt, y: yBigInt });

// From bytes (33-byte compressed or 65-byte uncompressed)
const p = Point.fromBytes(uint8array);

// From hex string
const p = Point.fromHex(hexString);
```

### Point Operations

```javascript
const p1 = point.add(otherPoint);           // Point addition
const p2 = point.double();                  // Point doubling
const p3 = point.subtract(otherPoint);      // Point subtraction
const p4 = point.negate();                  // Point negation
const p5 = point.multiply(scalarBigInt);    // Scalar multiplication

// Multi-scalar multiplication (MSM)
const points = [Point.BASE, Point.BASE.multiply(2n)];
const scalars = [3n, 5n];
const p6 = Point.msm(points, scalars);
```

### Point Properties & Checks

```javascript
point.equals(otherPoint);    // Check equality
point.is0();                 // Is point at infinity?
point.assertValidity();      // Validate point is on curve
point.isTorsionFree();       // Check if in prime subgroup
point.toBytes();             // Serialize to Uint8Array
point.toHex();               // Serialize to hex string
point.toAffine();            // Convert to affine coords {x, y}
```

---

## ECDSA Signature API (v2.x)

### Key Generation

```javascript
import { randomBytes } from '@noble/curves/abstract/utils.js';

// Auto-generate random key
const { secretKey, publicKey } = curve.keygen();

// From specific private key bytes
const secretKey = randomBytes(32);  // 32 bytes for 256-bit curves
const publicKey = curve.getPublicKey(secretKey);
```

### Signing

**Default behavior (v2.x)**: Messages are **prehashed** automatically

```javascript
// Default: prehash=true, lowS=true, format='compact'
const msg = new TextEncoder().encode('hello');
const sig = curve.sign(msg, secretKey);

// Custom options
const sig2 = curve.sign(msg, secretKey, {
  prehash: false,      // Don't hash message (provide hash yourself)
  lowS: false,         // Allow high-S signatures
  format: 'der',       // Use DER encoding instead of compact
  extraEntropy: true   // Add randomness for hedged signatures
});
```

### Verification

```javascript
// Verify compact signature (default)
const isValid = curve.verify(sig, msg, publicKey);

// Verify DER signature
const isValidDer = curve.verify(derSig, msg, publicKey, { format: 'der' });

// With custom prehash
const isValidCustom = curve.verify(sig, msgHash, publicKey, { prehash: false });
```

### Signature Formats

```javascript
// Compact: 64 bytes (32-byte r + 32-byte s)
const compactBytes = sig.toBytes('compact');
const sig1 = Signature.fromBytes(compactBytes, 'compact');

// DER: Variable length ASN.1 encoding
const derBytes = sig.toBytes('der');
const sig2 = Signature.fromBytes(derBytes, 'der');

// Hex formats
const compactHex = sig.toHex('compact');
const derHex = sig.toHex('der');
```

---

## Curve Validation (What the Library Checks)

When you call `weierstrass(params)`, the library validates:

1. **Generator point on curve**: Checks `Gy² = Gx³ + a*Gx + b (mod p)`
2. **Non-singular curve**: Checks discriminant `4a³ + 27b² ≠ 0 (mod p)`
3. **Valid order**: When Point operations are used, validates `n * G = O`

**Important**: If `n` is incorrect, you'll get error: `"Invalid curve, G*N != O"`

---

## Working with BigInt and Bytes

### Converting between formats

```javascript
import { hexToBytes, bytesToHex } from '@noble/curves/abstract/utils.js';

// Hex string to Uint8Array
const bytes = hexToBytes('deadbeef');

// Uint8Array to hex string
const hex = bytesToHex(new Uint8Array([0xde, 0xad, 0xbe, 0xef]));

// BigInt to hex string (no padding)
const hexBig = bigIntValue.toString(16);

// BigInt to hex string (with padding to specific length)
const hexPadded = bigIntValue.toString(16).padStart(64, '0');
```

---

## Key Differences: v2.x vs v1.x

### Breaking Changes in v2.x

1. **Prehashing**: Now **ON** by default (`prehash: true`)
   - v1: Messages were not hashed by default
   - v2: Messages are hashed with curve's hash function

2. **Low-S signatures**: Now **ON** by default (`lowS: true`)
   - Forces s value to be in lower half of range
   - Prevents signature malleability

3. **Signature format**: Default is now `'compact'` (64 bytes)
   - v1: DER was common
   - v2: Compact is default, DER requires explicit `{format: 'der'}`

4. **Input types**: Most methods now require `Uint8Array`
   - Hex strings only work with `fromHex()` methods
   - Use `Point.fromBytes()` for Uint8Array inputs

---

## Common Patterns

### Full ECDSA Flow

```javascript
import { weierstrass, ecdsa } from '@noble/curves/abstract/weierstrass.js';
import { sha256 } from '@noble/hashes/sha2.js';

// 1. Define curve parameters
const CURVE_PARAMS = { p, n, h, a, b, Gx, Gy };

// 2. Create Point class
const Point = weierstrass(CURVE_PARAMS);

// 3. Create ECDSA instance
const curve = ecdsa(Point, sha256);

// 4. Generate keys
const { secretKey, publicKey } = curve.keygen();

// 5. Sign
const message = new TextEncoder().encode('Hello World');
const signature = curve.sign(message, secretKey);

// 6. Verify
const isValid = curve.verify(signature, message, publicKey);
```

### Using Existing Private Key

```javascript
import { hexToBytes } from '@noble/curves/abstract/utils.js';

const privateKeyHex = '46c930bc7bb4db7f55da20798697421b98c4175a52c630294d75a84b9c126236';
const secretKey = hexToBytes(privateKeyHex);
const publicKey = curve.getPublicKey(secretKey);
```

---

## Error Handling

Common errors and their meanings:

1. **"Invalid curve, G*N != O"**
   - The order `n` is incorrect
   - `n` must be the exact number where `n * G = point at infinity`

2. **"bad point: is not on curve"**
   - Point coordinates don't satisfy curve equation
   - Check that `y² = x³ + ax + b (mod p)`

3. **"invalid scalar: out of range"**
   - Scalar must be in range `[1, n-1]`
   - Secret keys must be non-zero and less than curve order

4. **"bad point: equation left != right"**
   - Similar to "not on curve", but after computation
   - Usually indicates arithmetic error

---

## Security Considerations

1. **Order calculation is critical**: You MUST provide the correct order `n`
   - Cannot approximate with `p` or `p-1`
   - Use mathematical algorithms (Schoof's algorithm) to calculate

2. **Random number generation**: Uses `crypto.getRandomValues()`
   - Cryptographically secure on all modern platforms
   - Can provide custom RNG via `randomBytes` option

3. **Timing attacks**: Not constant-time due to JavaScript limitations
   - JIT compiler and garbage collector make constant-time difficult
   - For absolute security, use low-level languages

4. **Memory**: bigints and Uint8Arrays cannot be reliably zeroed
   - Sensitive data may remain in memory until garbage collection

---

## Modular Arithmetic Utilities

```javascript
import { mod, invert, Field } from '@noble/curves/abstract/modular.js';

// Basic modular operations
mod(21n, 10n);           // 21 mod 10 = 1n
invert(17n, 10n);        // modular multiplicative inverse

// Finite field operations
const Fp = Field(2n ** 255n - 19n);
Fp.mul(591n, 932n);      // multiplication in field
Fp.pow(481n, 11024n);    // exponentiation in field
Fp.div(5n, 17n);         // division: 5/17 mod p
Fp.inv(5n);              // modular inverse
Fp.sqrt(21n);            // square root mod p
```

---

## Performance Optimization

### Precomputation

```javascript
// Precompute multiples of base point for faster operations
Point.BASE.precompute(8);  // windowSize=8 (default)

// Precomputation happens automatically on first sign/verify
// but can be forced manually for predictable timing
```

### Point Validation

```javascript
// Expensive operation - only call when necessary
point.assertValidity();

// Cheaper checks
point.is0();              // Check if point at infinity
point.equals(otherPoint); // Check equality
```

---

## Example: Capicúa Curve Parameters

```javascript
// Custom curve with palindromic parameters
const CAPICUA_CURVE = {
  p: 2n ** 256n - 189n,                    // Prime field
  n: 0x...,                                 // MUST BE CALCULATED CORRECTLY!
  h: 1n,                                    // Cofactor
  a: 12345678987654321n,                   // Palindrome parameter
  b: 98765432123456789n,                   // Palindrome parameter  
  Gx: 4n,                                   // Generator X
  Gy: 7677010940438675858527404102889110377749302592279471034060180903517157070867n
};

// ⚠️ WARNING: 'n' cannot be approximated!
// You must calculate the exact order of point G on this curve
// Using Schoof's algorithm or similar point-counting method
```

---

## Useful Formulas

### Hasse's Bound

For a curve over prime field `Fp`, the number of points `#E(Fp)` satisfies:

```
|#E(Fp) - (p + 1)| ≤ 2√p
```

This gives you a range to search for the correct order `n`.

### Point Addition Formula (for reference)

Weierstrass curves use optimized formulas internally:
- Renes-Costello-Batina exception-free addition (complete formula)
- Cost: 12M + 0S + 3*a + 3*b3 + 23add

---

## Additional Resources

- **Repository**: https://github.com/paulmillr/noble-curves
- **Documentation**: https://paulmillr.com/noble/
- **Audit Reports**: Available in repo `/audit` folder
- **Test Vectors**: Wycheproof, cross-library tests included

---

## Summary Checklist for Custom Curves

- [ ] Define all parameters as `bigint` (use `n` suffix)
- [ ] Ensure `p` is prime
- [ ] Calculate exact order `n` (cannot approximate!)
- [ ] Verify generator point is on curve: `Gy² = Gx³ + a*Gx + b (mod p)`
- [ ] Check discriminant is non-zero: `4a³ + 27b² ≠ 0 (mod p)`
- [ ] Create Point class with `weierstrass()`
- [ ] Create ECDSA instance with `ecdsa(Point, hashFunction)`
- [ ] Test with `keygen()`, `sign()`, `verify()`
- [ ] Validate that `n * G = O` passes (library checks this)

---

**Last Updated**: October 2025  
**Library Version**: @noble/curves@2.0.1
